package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/merzzzl/proto-rest-api/restapi"
)

var version = "0.0.0-alpha.0"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()

	if *showVersion {
		_, _ = fmt.Printf("protoc-gen-go-rest %v\n", version)

		return
	}

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		files := make(map[string]*protogen.File)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			lf, ok := files[string(f.GoPackageName)]
			if !ok {
				files[string(f.GoPackageName)] = f

				continue
			}

			lf.Services = append(lf.Services, f.Services...)
			lf.Messages = append(lf.Messages, f.Messages...)
		}

		for _, lf := range files {
			generateFile(gen, lf)
		}

		return nil
	})
}

const (
	runtimePackage = protogen.GoImportPath("github.com/merzzzl/proto-rest-api/runtime")
	swaggerPackage = protogen.GoImportPath("github.com/merzzzl/proto-rest-api/swagger")
	httpPackage    = protogen.GoImportPath("net/http")
	stringsPackage = protogen.GoImportPath("strings")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_oapi.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-go-oapi. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-go-oapi v", version)
	g.P("// - protoc             ", protocVersion(gen))

	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}

	g.P()

	g.P("package ", file.GoPackageName)
	g.P()

	oapi := OAPIV3{
		OpenAPI: "3.0.3",
		Info: &InfoObject{
			Title:   toTitleString(string(file.GoPackageName)),
			Version: time.Now().Format(time.DateOnly),
		},
		Definitions: map[string]*SchemaObject{},
		Consumes:    []string{"application/json"},
		Produces:    []string{"application/json"},
		Paths:       map[string]map[string]*OperationObject{},
		Tags:        []*TagObject{},
	}

	for _, service := range file.Services {
		oapi.Tags = append(oapi.Tags, &TagObject{
			Name:        service.GoName,
			Description: formatComment(service.Comments.Leading.String()),
		})

		serviceOptions, ok := service.Desc.Options().(*descriptorpb.ServiceOptions)
		if !ok {
			exitWithError(fmt.Sprintf("unknown service options in %s", service.GoName))
		}

		extValSrv := proto.GetExtension(serviceOptions, restapi.E_Service)

		serviceRule, ok := extValSrv.(*restapi.ServiceRule)
		if !ok {
			exitWithError(fmt.Sprintf("unknown http options in %s", service.GoName))
		}

		basePath := serviceRule.GetBasePath()

		if basePath == "/" {
			exitWithError(fmt.Sprintf("base path %s is not allowed", basePath))
		}

		if basePath != "" {
			if basePath[0] != '/' {
				basePath = "/" + basePath
			}

			if basePath[len(basePath)-1] == '/' {
				basePath = basePath[:len(basePath)-1]
			}
		}

		for _, method := range service.Methods {
			methodOptions, ok := method.Desc.Options().(*descriptorpb.MethodOptions)
			if !ok {
				exitWithError(fmt.Sprintf("unknown method options in %s", method.GoName))
			}

			extVal := proto.GetExtension(methodOptions, restapi.E_Method)

			restRule, ok := extVal.(*restapi.MethodRule)
			if !ok {
				exitWithError(fmt.Sprintf("unknown http options in %s", method.GoName))
			}

			subPath := restRule.GetPath()

			if sep := strings.LastIndex(subPath, "?"); sep != -1 {
				path := subPath[:sep]

				if path == "/" {
					exitWithError(fmt.Sprintf("path %s is not allowed", path))
				}

				if path == "" {
					exitWithError("empty path is not allowed")
				}

				if path[0] != '/' {
					path = "/" + path
				}

				if path[len(path)-1] == '/' {
					path = path[:len(path)-1]
				}

				subPath = path + subPath[sep:]
			}

			oapiPath, pathParam, queryParams := getPathForOPAI(basePath + subPath)

			if oapi.Paths[oapiPath] == nil {
				oapi.Paths[oapiPath] = map[string]*OperationObject{}
			}

			pathItem := oapi.Paths[oapiPath]
			operation := &OperationObject{
				Tags:        []string{service.GoName},
				Summary:     formatComment(method.Comments.Leading.String()),
				OperationID: service.GoName + "_" + method.GoName,
				Parameters:  []*ParameterObject{},
				Responses:   map[string]*ResponseObject{},
			}

			if len(pathParam) > 0 {
				for _, param := range pathParam {
					operation.Parameters = append(operation.Parameters, &ParameterObject{
						Name:        param,
						In:          "path",
						Required:    true,
						Description: getDescriptionByName(method.Input, param),
						Schema:      getFieldSchemaByName(method.Input, param),
					})
				}
			}

			if len(queryParams) > 0 {
				for _, param := range queryParams {
					operation.Parameters = append(operation.Parameters, &ParameterObject{
						Name:        param,
						In:          "query",
						Required:    true,
						Description: getDescriptionByName(method.Input, param),
						Schema:      getFieldSchemaByName(method.Input, param),
					})
				}
			}

			pathItem[strings.ToLower(restRule.GetMethod())] = operation

			successCode := restRule.GetSuccessCode()
			if successCode == 0 {
				successCode = 200
			}

			if req := restRule.GetRequest(); req != "" {
				fileds := strings.Split(req, ".")

				if fileds[0] == "" {
					fileds = fileds[1:]
				}

				var ref string

				if fileds[0] == "*" {
					genMessageDefinitions(method.Input, oapi.Definitions)

					ref = getDefinitionsRef(method.Input.GoIdent.GoName)
				} else {
					field := fieldByPath(method.Input, fileds)

					genFieldDefinitions(field, oapi.Definitions)

					ref = getDefinitionsRef(field.GoIdent.GoName)
				}

				operation.RequestBody = &RequestBodyObject{
					Description: "A JSON object containing request parameters.",
					Content: map[string]*MediaTypeObject{
						"application/json": {
							Schema: SchemaObject{
								Ref: ref,
							},
						},
					},
					Required: true,
				}
			}

			if resp := restRule.GetResponse(); resp != "" {
				fileds := strings.Split(resp, ".")

				if fileds[0] == "" {
					fileds = fileds[1:]
				}

				var ref string

				if fileds[0] == "*" {
					genMessageDefinitions(method.Output, oapi.Definitions)

					ref = getDefinitionsRef(method.Output.GoIdent.GoName)
				} else {
					field := fieldByPath(method.Output, fileds)

					genFieldDefinitions(field, oapi.Definitions)

					ref = getDefinitionsRef(field.GoIdent.GoName)
				}

				operation.Responses[strconv.Itoa(int(successCode))] = &ResponseObject{
					Description: "A successful response.",
					Content: map[string]*MediaTypeObject{
						"application/json": {
							Schema: SchemaObject{
								Ref: ref,
							},
						},
					},
				}
			} else {
				operation.Responses[strconv.Itoa(int(successCode))] = &ResponseObject{
					Description: "A successful response.",
				}
			}
		}
	}

	spec, err := json.Marshal(oapi)
	if err != nil {
		exitWithError(err.Error())
	}

	g.P("// RegisterSwaggerUIHandler registers swagger ui handler.")
	g.P("func RegisterSwaggerUIHandler(mux ", runtimePackage.Ident("ServeMuxer"), ", path string) error {")
	g.P("if !", stringsPackage.Ident("HasPrefix"), "(path, \"/\") {")
	g.P("path = \"/\" + path")
	g.P("}")
	g.P()
	g.P("if !", stringsPackage.Ident("HasSuffix"), "(path, \"/\") {")
	g.P("path += \"/\"")
	g.P("}")
	g.P()
	g.P("fs, err := ", swaggerPackage.Ident("GetSwaggerUI"), "(swaggerJSON, path)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P()
	g.P("mux.Handle(path, ", httpPackage.Ident("FileServer"), "(fs))")
	g.P()
	g.P("return nil")
	g.P("}")
	g.P()

	g.P("// RegisterReDocUIHandler registers redoc ui handler.")
	g.P("func RegisterReDocUIHandler(mux ", runtimePackage.Ident("ServeMuxer"), ", path string) error {")
	g.P("if !", stringsPackage.Ident("HasPrefix"), "(path, \"/\") {")
	g.P("path = \"/\" + path")
	g.P("}")
	g.P()
	g.P("if !", stringsPackage.Ident("HasSuffix"), "(path, \"/\") {")
	g.P("path += \"/\"")
	g.P("}")
	g.P()
	g.P("fs, err := ", swaggerPackage.Ident("GetReDocUI"), "(swaggerJSON, path)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P()
	g.P("mux.Handle(path, ", httpPackage.Ident("FileServer"), "(fs))")
	g.P()
	g.P("return nil")
	g.P("}")
	g.P()

	g.P("var swaggerJSON = []byte{")
	g.P(printByteArray(spec))
	g.P("}")
	g.P()
}

func printByteArray(data []byte) string {
	var sb strings.Builder

	count := 0

	for _, b := range data {
		count++

		if count > 16 {
			_, _ = sb.WriteString("\n")

			count = 1
		}

		_, _ = sb.WriteString(fmt.Sprintf("0x%02x,", b))
	}

	return sb.String()
}

func toTitleString(s string) string {
	if s == "" {
		return "Swagger"
	}

	seps := strings.Split(s, "_")

	for i, sep := range seps {
		seps[i] = string(unicode.ToUpper(rune(sep[0]))) + sep[1:]
	}

	return strings.Join(seps, "")
}

func formatComment(s string) string {
	s = strings.TrimPrefix(s, "//")
	s = strings.TrimSuffix(s, "\n")
	s = strings.TrimSpace(s)

	return s
}

func getPathForOPAI(s string) (string, []string, []string) {
	pathParams := []string{}
	queryParams := []string{}

	splited := strings.Split(s, "?")

	segs := strings.Split(splited[0], "/")
	for i, seg := range segs {
		if strings.HasPrefix(seg, ":") {
			pathParams = append(pathParams, seg[1:])

			segs[i] = fmt.Sprintf("{%s}", seg[1:])
		}
	}

	if len(splited) > 1 {
		for _, param := range strings.Split(splited[1], "&") {
			if strings.HasPrefix(param, ":") {
				queryParams = append(queryParams, param[1:])
			}
		}
	}

	return strings.Join(segs, "/"), pathParams, queryParams
}

func fieldByPath(msg *protogen.Message, fileds []string) *protogen.Field {
	for _, field := range msg.Fields {
		if field.Desc.TextName() == fileds[0] {
			if len(fileds) == 1 {
				return field
			}

			return fieldByPath(field.Message, fileds[1:])
		}
	}

	exitWithError(fmt.Sprintf("unknown field %s in %s", fileds[0], msg.GoIdent))

	return nil
}

func genMessageDefinitions(msg *protogen.Message, properties map[string]*SchemaObject) map[string]*SchemaObject {
	if properties[msg.GoIdent.GoName] != nil {
		return properties
	}

	schema := &SchemaObject{
		Type:       "object",
		Properties: map[string]*SchemaObject{},
	}

	for _, field := range msg.Fields {
		if field.Oneof != nil {
			for _, field := range field.Oneof.Fields {
				if field.Message != nil {
					_ = genMessageDefinitions(field.Message, properties)

					schema.Properties[field.Desc.JSONName()] = &SchemaObject{
						Ref: getDefinitionsRef(field.Message.GoIdent.GoName),
					}
				} else {
					schema.Properties[field.Desc.JSONName()] = getSchemaObjectForField(field)
				}
			}

			continue
		}

		if field.Message != nil {
			_ = genMessageDefinitions(field.Message, properties)

			if field.Desc.IsList() {
				schema.Properties[field.Desc.JSONName()] = &SchemaObject{
					Type: "array",
					Items: &SchemaObject{
						Ref: getDefinitionsRef(field.Message.GoIdent.GoName),
					},
				}
			} else {
				schema.Properties[field.Desc.JSONName()] = &SchemaObject{
					Ref: getDefinitionsRef(field.Message.GoIdent.GoName),
				}
			}

			continue
		}

		schema.Properties[field.Desc.JSONName()] = getSchemaObjectForField(field)
	}

	properties[msg.GoIdent.GoName] = schema

	return properties
}

func getFieldSchemaByName(msg *protogen.Message, name string) *SchemaObject {
	for _, field := range msg.Fields {
		if field.Desc.TextName() == name {
			return getSchemaObjectForField(field)
		}
	}

	return nil
}

func getDescriptionByName(msg *protogen.Message, name string) string {
	for _, field := range msg.Fields {
		if field.Desc.TextName() == name {
			return formatComment(field.Comments.Trailing.String())
		}
	}

	return ""
}

func getListDefinitions(field *protogen.Field, properties map[string]*SchemaObject) map[string]*SchemaObject {
	if properties[field.GoIdent.GoName] != nil {
		return properties
	}

	schema := &SchemaObject{
		Type:  "array",
		Items: &SchemaObject{},
	}

	if field.Message != nil {
		_ = genMessageDefinitions(field.Message, properties)

		schema.Items.Ref = getDefinitionsRef(field.Message.GoIdent.GoName)
	} else {
		schema.Items = getSchemaObjectForField(field)
	}

	properties[field.GoIdent.GoName] = schema

	return properties
}

func genFieldDefinitions(field *protogen.Field, properties map[string]*SchemaObject) {
	if properties[field.GoIdent.GoName] != nil {
		return
	}

	if field.Desc.IsList() {
		getListDefinitions(field, properties)

		return
	}

	if field.Message != nil {
		properties = genMessageDefinitions(field.Message, properties)

		properties[field.GoIdent.GoName] = &SchemaObject{
			Ref: getDefinitionsRef(field.Message.GoIdent.GoName),
		}
	}
}

func getSchemaObjectForField(field *protogen.Field) *SchemaObject {
	var schema *SchemaObject

	switch field.Desc.Kind() {
	default:
		exitWithError(fmt.Sprintf("unknown field type %s", field.Desc.Kind()))
	case protoreflect.BoolKind:
		schema = &SchemaObject{
			Type: "boolean",
		}
	case protoreflect.Int32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind:
		schema = &SchemaObject{
			Type:   "integer",
			Format: "int32",
		}
	case protoreflect.Uint32Kind:
		schema = &SchemaObject{
			Type:    "integer",
			Format:  "uint32",
			Minimum: 0,
		}
	case protoreflect.Int64Kind, protoreflect.Sfixed64Kind, protoreflect.Fixed64Kind:
		schema = &SchemaObject{
			Type:   "integer",
			Format: "int64",
		}
	case protoreflect.Uint64Kind:
		schema = &SchemaObject{
			Type:    "integer",
			Format:  "uint32",
			Minimum: 0,
		}
	case protoreflect.FloatKind:
		schema = &SchemaObject{
			Type:   "number",
			Format: "float",
		}
	case protoreflect.DoubleKind:
		schema = &SchemaObject{
			Type:   "number",
			Format: "double",
		}
	case protoreflect.StringKind, protoreflect.BytesKind:
		schema = &SchemaObject{
			Type: "string",
		}
	case protoreflect.EnumKind:
		schema = &SchemaObject{
			Type: "string",
			Enum: enumValues(field.Enum),
		}
	}

	if field.Desc.IsList() {
		schema = &SchemaObject{
			Type:  "array",
			Items: schema,
		}
	}

	return schema
}

func enumValues(enum *protogen.Enum) []string {
	values := make([]string, len(enum.Values))

	for i, v := range enum.Values {
		values[i] = string(v.Desc.Name())
	}

	return values
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}

	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}

	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func exitWithError(message string) {
	_, _ = fmt.Fprintln(os.Stderr, message)
	os.Exit(1)
}

type OAPIV3 struct {
	OpenAPI     string                                 `json:"openapi"`
	Info        *InfoObject                            `json:"info"`
	Consumes    []string                               `json:"consumes,omitempty"`
	Produces    []string                               `json:"produces,omitempty"`
	Paths       map[string]map[string]*OperationObject `json:"paths,omitempty"`
	Definitions map[string]*SchemaObject               `json:"definitions,omitempty"`
	Tags        []*TagObject                           `json:"tags,omitempty"`
}

type TagObject struct {
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
}

type InfoObject struct {
	Title   string `json:"title"`
	Version string `json:"version"`
}

type OperationObject struct {
	Summary     string                     `json:"summary,omitempty"`
	OperationID string                     `json:"operationId"` //nolint:tagliatelle // is openapi field name
	Tags        []string                   `json:"tags,omitempty"`
	Parameters  []*ParameterObject         `json:"parameters,omitempty"`
	RequestBody *RequestBodyObject         `json:"requestBody,omitempty"`
	Responses   map[string]*ResponseObject `json:"responses"`
}

type ResponseObject struct {
	Description string                      `json:"description"`
	Content     map[string]*MediaTypeObject `json:"content,omitempty"`
}

type ParameterObject struct {
	Name        string        `json:"name,omitempty"`
	In          string        `json:"in,omitempty"`
	Required    bool          `json:"required,omitempty"`
	Schema      *SchemaObject `json:"schema,omitempty"`
	Description string        `json:"description,omitempty"`
}

type RequestBodyObject struct {
	Description string                      `json:"description"`
	Content     map[string]*MediaTypeObject `json:"content,omitempty"`
	Required    bool                        `json:"required,omitempty"`
}

type MediaTypeObject struct {
	Schema SchemaObject `json:"schema,omitempty"`
}

type SchemaObject struct {
	Type       string                   `json:"type,omitempty"`
	Format     string                   `json:"format,omitempty"`
	Properties map[string]*SchemaObject `json:"properties,omitempty"`
	Ref        string                   `json:"$ref,omitempty"`
	Minimum    int                      `json:"minimum,omitempty"`
	Enum       []string                 `json:"enum,omitempty"`
	Items      *SchemaObject            `json:"items,omitempty"`
}

func getDefinitionsRef(name string) string {
	return "#/definitions/" + name
}
